<link rel="stylesheet" href="MAPS/leaflet.css" />
<script src="MAPS/leaflet.js"></script>
<script src="bclib.js"></script>

<style>html,body, #map {height:100%;}</style>
<div id="map"></div>

<script>

// hash1 = {'a': 3, 'b': 4, 'c': 5};
// hash2 = {'a': 4, 'e': 7, 'f': 4};

// console.log(mergeHashes(hash1, hash2));

// spread operator doesn't work
// console.log({...hash1, ...hash2});

// note for ... style merges, second overwrites first

// console.log(str2hash("a=1&b=2&c=3"));

// console.log(tile2LngLat({z: 5, x: 2, y: 32, projection: 1}));

// console.log(lngLat2Tile({lng: 0, lat: 85, z: 3, projection: 1}));
// console.log(tile2LngLat({x: 4, z: 3, y: 0, projection: 1}));

// placeTilesOnMap({map: "foo"});

// this is a HACK function to figure out where I put climate tiles on
// my server (I used a really weird naming scheme)-- in general, this can
// be computed much better-- returns tile name and bounds

// expected params:

// origTileZoom: the original tiles are at this zoom level
// (theoretically computable from width assuming pixelized tiles weren't
// created)

function hack_beck2_tiles(obj) {

  // this is now a testbed for tiles created by:
  // gdal_retile.py imagefile -levels 8 -v -targetDir CLIMATE2 -of png
  // I put the tiles created in the main directory into 0/ for consistency

  // this will replace placeTilesOnMap() for sliced images

  let z = obj.map.getZoom();
  td(z,"Z");

  var url;

  // based on image height/width, determine which tiles I want to use
  // 0 = 256x256 tiles (highest resolution)
  // 1 = 512x512 tiles (reduced to 256x256)

  //  td(2**(z+8), "RESOLUTION");


  let mapBounds = obj.map.getBounds();

  // TODO: this could be functionalized

  // TODO: consider toBBoxString here
  // TODO: images are assumed equirectangular projected for now

  let n = boundNumber(mapBounds.getNorth(), -90, 90);
  let s = boundNumber(mapBounds.getSouth(), -90, 90);
  let e = boundNumber(mapBounds.getEast(), -180, 180);
  let w = boundNumber(mapBounds.getWest(), -180, 180);

  let nw = lngLat2ImageTile(mergeHashes(obj, {lat: n, lng: w, z: z}));
  let se = lngLat2ImageTile(mergeHashes(obj, {lat: s, lng: e, z: z}));

  td([n,e,s,w,z, se, nw], "DIRS,Z,SE,NW");

  for (let i = Math.floor(nw.x); i <= Math.floor(se.x); i++) {
    for (let j = Math.floor(se.y); j <= Math.floor(nw.y); j++) {

      let bounds0 = imageTile2LngLat(mergeHashes(obj, {z: z, x: i, y: j}));
      let bounds1 = imageTile2LngLat(mergeHashes(obj, {z: z, x: i+1, y: j+1}));
      url = convertStringTemplate(obj.tileURL, {x: i, y: j, z: z});

            L.imageOverlay(url, [bounds0, bounds1], 
      			   {opacity: obj.opacity}).addTo(obj.map);

      td([url, bounds0, bounds1], "ALPHA");
    }
  }

  // figure out the level 0 tiles (in gdal_retile these are the
  // highest resolution tiles)

  // TODO: functionalize

  /*
  let yStart = (90-n)/180*height/256;
  let yEnd = (90-s)/180*height/256;
  let xStart = (w/360+1/2)*width/256;
  let xEnd = (e/360+1/2)*width/256;
  */



  td([n,s,e,w], "NSEW");

  // figure out pixel coords in huge map and then in 256x256 tiles

  //  td([(90-n)/180*height/256, (90-s)/180*height/256], "ALPHA");

  //  td([(90-n)/180*height/256/2**5, (90-s)/180*height/256/2**5], "ALPHA");

  /*
  td([
      (90-n)/180*height/256/2**0, 
      (90-s)/180*height/256/2**0,
      (w/360+1/2)*width/256/2**0,
      (e/360+1/2)*width/256/2**0
      ], "ALPHA");
  */
  

  // find the highest power of two dividing height (above this zoom
  // level (minus 8 for 256x256 tiles), we must display tiles at full
  // resolution)

  //  let highZoom = Math.floor(Math.log(height)/Math.log(2))-8;

  // for lower zoom levels, we can use lower resolution tiles

  //  let tileZoom = highZoom - z;

  //  td([z, tileZoom, highZoom], "STUFF");
  

	returnHash = {};

	//	td(obj, "input object");

	// the original image is 43200 x 21600
	// this is a hack
	obj.width = 43200;

	// at zoom level 8, the world is 65536 by 65536 so need full tiles

	// at zoom level 7, world is 32768^2, so still need full tiles

	// at zoom level 6, world is 16384, so STILL need full for 21600 dim

	// at zoom level 5, world is 8192, so can use half size tiles

	
	// original tile size


	// number of tiles per row

	//	let tilesPerRow = Math.ceil(obj.width/origTileSize);

	// the tile I want

	//	let tileNumber = obj.y*tilesPerRow + obj.x;

	//	td({obj, origTileSize, tileNumber, tilesPerRow}, "");

	//	td([tilesPerRow, origTileSize, tileNumber], "tpr/size/num");

	// and now the url

	//	returnHash.url = `http://test.barrycarter.info/BECK2/${origTileSize}/beck_kg_${origTileSize}_${tileNumber}.png`;

	return returnHash;

}

let map = L.map('map', {crs: L.CRS.Simple});
map.fitBounds([[-90, -180], [90, 180]]);
// map.flyTo([25.8, -79.1], 7);
map.on('zoomend', redraw_map);
map.on('moveend', redraw_map);
// can't set zoom from 3 to 6 for some reason?!@?!
map.setView([25.8, -79.1], 7);
redraw_map();


// for testing, set to Florida

// TODO: pass image base too

/*
console.log(hack_beck2_tiles({map: map, opacity: 0.5, width: 43200, 
	height: 21600, origTileZoom: 8,
	tileURL: 'http://ws.terramapadventure.com/CLIMATE/${z}/${y}/${x}.png'
	}))
*/

function redraw_map() {

  // TODO: not this
  map.eachLayer(function(layer) {layer.remove()});

  // testing

  hack_beck2_tiles({map: map, opacity: 1, width: 43200,
	height: 21600, origTileZoom: 8,
	tileURL: 'http://ws.terramapadventure.com/CLIMATE/${z}/${x}/${y}.png'
	});

  return;

  
  // climate map on new server
  placeTilesOnMap({map: map, projection: 1, opacity: 1, fake: 1,
	tileURL: "http://ws.terramapadventure.com/CLIMATE/${z}/${x}/${y}.png"
	});


  // climate map on new server
  placeTilesOnMap({map: map, projection: 1, opacity: 1,
	tileURL: "http://ws.terramapadventure.com/LANDUSE/${z}/${x}/${y}.png"
	});


return;

//  hack_beck2_tiles({map: map, opacity: 0.5});

  // my coord map

  placeTilesOnMap({map: map, projection: 1, opacity: 0.5,
	tileURL: "http://test.barrycarter.info/bc-mytile3.pl?/${z}/${x}/${y}.png"
	});

  // the OSM map
  placeTilesOnMap({map: map, projection: 1, opacity: 0.5,
	tileURL: "https://a.tile.openstreetmap.org/${z}/${x}/${y}.png"
	});

  // probably not working Beck climate map
  //  placeTilesOnMap({map: map, projection: 0, opacity: 0.5,
  //	tileURL: "http://test.barrycarter.info/BECK/${z}/beck_${x}_${y}.png"
  //	});

}



// applyFunctionToHashValues({hash: {a: 1.6, b: 2.4, c:3.7 }, f: Math.floor});

</script>
