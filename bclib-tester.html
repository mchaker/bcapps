<link rel="stylesheet" href="MAPS/leaflet.css" />
<script src="MAPS/leaflet.js"></script>
<script src="bclib.js"></script>

<style>html,body, #map {height:100%;}</style>
<div id="map"></div>

<script>

// hash1 = {'a': 3, 'b': 4, 'c': 5};
// hash2 = {'a': 4, 'e': 7, 'f': 4};

// console.log(mergeHashes(hash1, hash2));

// spread operator doesn't work
// console.log({...hash1, ...hash2});

// note for ... style merges, second overwrites first

// console.log(str2hash("a=1&b=2&c=3"));

// console.log(tile2LngLat({z: 5, x: 2, y: 32, projection: 1}));

// console.log(lngLat2Tile({lng: 0, lat: 85, z: 3, projection: 1}));
// console.log(tile2LngLat({x: 4, z: 3, y: 0, projection: 1}));

// placeTilesOnMap({map: "foo"});

// this is a HACK function to figure out where I put climate tiles on
// my server (I used a really weird naming scheme)-- in general, this can
// be computed much better-- returns tile name and bounds

function hack_beck2_tiles(obj) {

  // this is now a testbed for tiles created by:
  // gdal_retile.py imagefile -levels 8 -v -targetDir CLIMATE2 -of png
  // I put the tiles created in the main directory into 0/ for consistency

  // this will replace placeTilesOnMap() for sliced images

  // TODO: pass these as parameters

  let width = 43200;
  let height = width/2;

  let z = obj.map.getZoom();

  let mapBounds = obj.map.getBounds();

  console.log(mapBounds.toBBoxString());

  // TODO: this could be functionalized


  // TODO: consider toBBoxString here
  // TODO: images are assumed equirectangular projected for now

  let n = boundNumber(mapBounds.getNorth(), -90, 90);
  let s = boundNumber(mapBounds.getSouth(), -90, 90);
  let e = Math.min(Math.max(-180, mapBounds.getEast()), 180);
  let w = Math.min(Math.max(-180, mapBounds.getWest()), 180);

  // figure out the level 0 tiles (in gdal_retile these are the
  // highest resolution tiles)

  // TODO: functionalize

  let yStart = (90-n)/180*height/256;
  let yEnd = (90-s)/180*height/256;
  let xStart = (w/360+1/2)*width/256;
  let xEnd = (e/360+1/2)*width/256;




  td([n,s,e,w], "NSEW");

  // figure out pixel coords in huge map and then in 256x256 tiles

  //  td([(90-n)/180*height/256, (90-s)/180*height/256], "ALPHA");

  //  td([(90-n)/180*height/256/2**5, (90-s)/180*height/256/2**5], "ALPHA");
  td([
      (90-n)/180*height/256/2**0, 
      (90-s)/180*height/256/2**0,
      (w/360+1/2)*width/256/2**0,
      (e/360+1/2)*width/256/2**0
      ], "ALPHA");
  

  // find the highest power of two dividing height (above this zoom
  // level (minus 8 for 256x256 tiles), we must display tiles at full
  // resolution)

  let highZoom = Math.floor(Math.log(height)/Math.log(2))-8;

  // for lower zoom levels, we can use lower resolution tiles

  let tileZoom = highZoom - z;

  td([z, tileZoom, highZoom], "STUFF");
  

	returnHash = {};

	//	td(obj, "input object");

	// the original image is 43200 x 21600
	// this is a hack
	obj.width = 43200;

	// at zoom level 8, the world is 65536 by 65536 so need full tiles

	// at zoom level 7, world is 32768^2, so still need full tiles

	// at zoom level 6, world is 16384, so STILL need full for 21600 dim

	// at zoom level 5, world is 8192, so can use half size tiles

	
	// original tile size


	// number of tiles per row

	//	let tilesPerRow = Math.ceil(obj.width/origTileSize);

	// the tile I want

	//	let tileNumber = obj.y*tilesPerRow + obj.x;

	//	td({obj, origTileSize, tileNumber, tilesPerRow}, "");

	//	td([tilesPerRow, origTileSize, tileNumber], "tpr/size/num");

	// and now the url

	//	returnHash.url = `http://test.barrycarter.info/BECK2/${origTileSize}/beck_kg_${origTileSize}_${tileNumber}.png`;

	return returnHash;

}


td(imageTile2LngLat({x: 5, y: 7, z: 0, height: 21600, width: 43200}));
td(imageTile2LngLat({x: 5, y: 7, z: 2, height: 21600, width: 43200}));
td(imageTile2LngLat({x: 5, y: 7, z: 5, height: 21600, width: 43200}));


let map = L.map('map', {crs: L.CRS.Simple});
map.fitBounds([[-90, -180], [90, 180]]);
map.on('zoomend', redraw_map);
map.on('moveend', redraw_map);

// for testing, set to Florida

// map.flyTo([25.8, -79.1], 7);
map.setView([25.8, -79.1], 7);

redraw_map();

// TODO: pass image base too
console.log(hack_beck2_tiles({map: map, opacity: 0.5}))


// redraw_map();

function redraw_map() {

  // TODO: not this
  map.eachLayer(function(layer) {layer.remove()});

  hack_beck2_tiles({map: map, opacity: 0.5});

  // my coord map
  placeTilesOnMap({map: map, projection: 1, opacity: 0.5,
	tileURL: "http://test.barrycarter.info/bc-mytile3.pl?/${z}/${x}/${y}.png"
	});

  // the OSM map
  placeTilesOnMap({map: map, projection: 1, opacity: 0.5,
	tileURL: "https://a.tile.openstreetmap.org/${z}/${x}/${y}.png"
	});

  // probably not working Beck climate map
  //  placeTilesOnMap({map: map, projection: 0, opacity: 0.5,
  //	tileURL: "http://test.barrycarter.info/BECK/${z}/beck_${x}_${y}.png"
  //	});

}



// applyFunctionToHashValues({hash: {a: 1.6, b: 2.4, c:3.7 }, f: Math.floor});

</script>
