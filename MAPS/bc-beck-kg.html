<link rel="stylesheet" href="leaflet.css" />
<script src="leaflet.js"></script>
<script src="proj4-compressed.js"></script>
<script src="proj4leaflet.js"></script>
<script src="bounds.js"></script>
<script src="sprintf.js"></script>
<style>html,body, #map {height:100%;}</style>
<div id="map"></div>

<script>

// the latitude limit for square Mercator maps
var latLimit = 85.0511;

// create map and zoom it to correct y, x limits
var map = L.map('map', {crs: L.CRS.Simple});
map.fitBounds([[-90, -180], [90, 180]]);
map.on('zoomend', redraw_map);
map.on('moveend', redraw_map);

// get the tile and lat/lon extents of a given map, adjusting for
// "impossible" cases

function getMapExtents(m) {

  let ret = {};

  let zoom = map.getZoom();
  let mapBounds = map.getBounds();

  ret.zoom = zoom;

  // the minimum latitude we are viewing and the y value associated
  // with that tile (which is actually maxY because south = higher y)

  ret.minLat = Math.max(mapBounds._southWest.lat, -latLimit);
  ret.maxY = lat2tile(ret.minLat, zoom);

  // and same for maxLat
  ret.maxLat = Math.min(mapBounds._northEast.lat, latLimit);
  ret.minY = lat2tile(ret.maxLat, zoom);

  // and for longitude
  ret.minLong = Math.max(mapBounds._southWest.lng, -180);
  ret.minX = long2tile(ret.minLong, zoom);

  ret.maxLong = Math.min(mapBounds._northEast.lng, 180);
  ret.maxX = long2tile(ret.maxLong, zoom);

  // TODO: put this into function
  if (ret.maxX == 2**zoom) {ret.maxX--;}

  // if you're using equirectangular tiles, your latitude bounds are
  // different, but easy to compute

  ret.maxYRect = lat2TileRect(ret.minLat, zoom);
  ret.minYRect = lat2TileRect(ret.maxLat, zoom);

  return ret;
}


// converts latitude to rectangular tile number, not slippy tile
// and the other way

function tileRect2lat(y, z) {return y/2**z*180-90;}

function lat2TileRect(lat, z) {return Math.floor(2**z*(90-lat)/180);}

// next 4 functions are cut/pasted from elsewhere
// TODO: move them to library
// TODO: not crazy about them flooring-- partial tile location is valuable too
  
function tile2long(x,z) {return (x/Math.pow(2,z)*360-180);}

function tile2lat(y,z) {
  var n=Math.PI-2*Math.PI*y/Math.pow(2,z);
  return (180/Math.PI*Math.atan(0.5*(Math.exp(n)-Math.exp(-n))));
}

// TODO: this returns 1 number too high for exactly 180 degrees
function long2tile(lon,zoom) { return (Math.floor((lon+180)/360*Math.pow(2,zoom))); }
function lat2tile(lat,zoom)  { return (Math.floor((1-Math.log(Math.tan(lat*Math.PI/180) + 1/Math.cos(lat*Math.PI/180))/Math.PI)/2 *Math.pow(2,zoom))); }

// given a map m, a baseURL and string s such that
// baseURL/{n}/str_{n}_{k}.png is the kth slippy tile at zoom level n,
// paint the necessary tiles on to map

function tiles2Map(m, baseURL, s) {

  var str, num, bounds;

  // find the zoom level and the x and y extents
  let mapBounds = getMapExtents(m);

  for (let i = mapBounds.minX; i <= mapBounds.maxX; i++) {
    for (let j = mapBounds.minYRect; j <= mapBounds.maxYRect; j++) {

      // tiles are single numbered
      num = j*2**mapBounds.zoom + i;

      // find the URL
      str = `${baseURL}/${mapBounds.zoom}/${s}_${mapBounds.zoom}_${num}.png`;

      // put in the right place
      // TODO: probably shouldn't create a new ImageOverlay everytime




      console.log(str);
    }
  }
}

// smaller imageoverlays

redraw_map();

function redraw_map () {
  tiles2Map(map, "http://test.barrycarter.info/BECK", "beck_kg");
}


</script>
