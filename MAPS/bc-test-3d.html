<script src="../bclib.js"></script>
<script src="../bclib-staging.js"></script>
<script src="bc-osmtilecache.js"></script>
<script src="../THREE.JS/three.min.js"></script>
<div id="container"></div>

<script>

// Create renderer, camera, scne
let renderer = new THREE.WebGLRenderer();
let camera = new THREE.PerspectiveCamera(90);
let scene = new THREE.Scene();

// Put renderer in container above
document.querySelector('#container').appendChild(renderer.domElement);

// Set rendeer scene, add camera

scene.add(camera);
renderer.setSize(700, 700);

// Attach the renderer-supplied DOM element.
container.appendChild(renderer.domElement);

// create sphere shards for zoom level 4

let shard = [];

for (let i=0; i<2; i++) {
  shard[i] = [];
  for (let j=0; j<2; j++) {

    let nwtile = tile2LngLat({z: 1, x: i, y: j, projection: 1});
    let setile = tile2LngLat({z: 1, x: i+1, y: j+1, projection: 1});

    // i=0, j=1 prints, as does i=1, j=1, and i=1, j=0

    // i=1, j=0 prints NE hemisphere in rightish place

//    if (i != 1 || j!= 1) {continue;}

    // phistart doesn't take negative numbers?
//    if (setile.lat < 0) {setile.lat += 360; nwtile.lat += 360;}

    // testing
//    if (i != 5 | j != 8) {continue;}

    console.log("TILES", nwtile, setile);

    shard[i][j] = new THREE.Mesh(new THREE.SphereGeometry(1, 10, 10, 
                    nwtile.lng*Degree, (setile.lng-nwtile.lng)*Degree,
                    -setile.lat*Degree, (nwtile.lat-setile.lat)*Degree),
		    new THREE.MeshBasicMaterial( {color: 0x8080ff} ));;


   // put the correct slippy tile on it
   shard[i][j].material.map = THREE.ImageUtils.loadTexture(URLCache.cache[`https://tile.openstreetmap.org/1/${i}/${j}.png`]);

//   console.log(shard[i][j].material);

   // if not set, color is random		    
//   shard[i][j].material.color = [0, 0, 255];

    scene.add(shard[i][j]);
  }
 }

/*

for (let i=0; i<16; i++) {
  shard[i] = [];
  for (let j=0; j<16; j++) {
    let nwtile = tile2LngLat({z: 4, x: i, y: j, projection: 1});
    let setile = tile2LngLat({z: 4, x: i+1, y: j+1, projection: 1});

    // phistart doesn't take negative numbers?
    if (setile.lat < 0) {setile.lat += 360; nwtile.lat += 360;}

    // testing
//    if (i != 5 | j != 8) {continue;}

    console.log("TILES", nwtile, setile);

    shard[i][j] = new THREE.Mesh(new THREE.SphereGeometry(1, 10, 10, 
                    nwtile.lng*Degree, (setile.lng-nwtile.lng)*Degree,
                    setile.lat*Degree, (nwtile.lat-setile.lat)*Degree),
		    new THREE.MeshBasicMaterial( {color: 0x8080ff} ));;


   // put the correct slippy tile on it
   shard[i][j].material.map = THREE.ImageUtils.loadTexture(URLCache.cache[`https://tile.openstreetmap.org/4/${i}/${j}.png`]);

//   console.log(shard[i][j].material);

   // if not set, color is random		    
//   shard[i][j].material.color = [0, 0, 255];

    scene.add(shard[i][j]);
  }
 }

*/

// Set up the sphere vars

const sphere = new THREE.Mesh(new THREE.SphereGeometry(1));

sphere.material.map = THREE.ImageUtils.loadTexture(URLCache.cache['https://tile.openstreetmap.org/0/0/0.png']);

// Move the Sphere back in Z so we can see it.
// sphere.position.z = -1.5;

camera.position.z = 1.5;

// Finally, add the sphere to the scene.
// scene.add(sphere);

function update () {
 renderer.render(scene, camera);
 requestAnimationFrame(update);
}

// Schedule the first frame.
requestAnimationFrame(update);

</script>
